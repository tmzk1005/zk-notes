---
title: "数据库事务隔离级别"
date: 2021-02-18T11:27:39+08:00
draft: false
---

# ACID

事务是一组原子性的SQL语句的执行过程，要么全部失败，要么全部成功。事务有4个特性，即ACID：

### A-原子性
一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

### C-一致性
数据库总是从一个一致性的状态转化到另外一个一致性的状态。以银行转账本过程来距离说明，不能存在被转账方钱数已经增加成功，但是转账方的钱数却没有扣除的情形。这破坏了数据的一致性。

### I-隔离性
通常来说一个事务所做的修改在最终提交成功之前，应该对其他事务是不可见的。举例来说，假设一个事务有2条insert语句分别新插入2个新纪录，在第一条insert语句执行之后，但是第二条insert语句执行之前，其他的用户这时查询数据库，应该是不能查到第一条语句插入的数据的。绝对的隔离性会导致数据库执行事务的性能较低，因此sql标准其实定义了4种隔离级别，这就是前面为什么说是“通常来说”。

### D-持久性
一旦事务成功提交，则其所做的改动将永久的保存到数据库中。

# 事务的隔离级别
绝对的隔离下，一个事务的中间状态对其他事务来说是不可见的，但是绝对的隔离性能低，sql标准定义了4种隔离级别，每种级别都规定了一个事务中所做的修改，在还没有提交的中间状态下，那些是其他事务可见的，那些是不可见的。较低的事务隔离级别通常可以支持更高的并发，系统的开销也更低。

下面依此由隔离级别从低到高简单介绍下事务的隔离级别：

## read uncommitted（未提交读）

在read uncommitted级别，事务中的修改，即是没有提交，对其他事务也都是可见的。select语句可以查询到其他正在执行但是还没提交的事务所插入的数据，这种情况被称之为“**脏读**”。这个级别最低，会导致很多的问题，比如一个事务插入一条记录，然后被其他的select语句读取到，但是事务最终失败回滚了，那么就相当于select语句查到了一条不存在的数据。

read uncommitted的性能并不会比其他的级别好太多，但是却有很多问题，一般很少使用，除非真的有非常必要的理由。

## read committed（提交读）

read committed满足隔离型的简单定义：一个事务开始时，只能看见已经提交的事务所做出的改动。换句话说，一个事务从开始执行到提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫做“**不可重复读**”（nonrepeatable read），因为在同一个事务中，读取同一个记录多次，可能得到不同的结果。假设在一个表中，id是主键，具有唯一性，同时有另外一个字段age表示年龄，在时刻1，事务A使用“id=5”读取id为5的记录得到age=20，然后另外一个事务B修改了id=5的记录的age字段值为25并成功提交，然后在时刻2，事务A再次使用一摸一样的select语句读取了id=5的记录，确得到了完全不一样的age值。

大多数的数据库系统的默认隔离级别都是read committed，但是mysql不是。

## repeatable read（可重复读）

可重复读解决了“脏读”的问题，也解决了“重复读的问题”，在前面的例子中，该级别保证了在同一个事务中查询同一条记录，查询到的结果是一样的。但是理论上，可重复读隔离级别还是无法解决“幻读”的问题。所谓“**幻读**”，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生“幻行”。还是前面的id和age例子，假设在时刻1，事务A使用“age=10”来查询出多行记录，假设为n，然后事务B插入了一条全新的数据并提交成功，其age也为10，然后在时刻2，事务A执行同样的查询，确得到了n+1条记录。

repeatable read是mysql的默认隔离级别，并且mysql的innodb通过MVCC在**大部分场景下**解决了在repeatable read隔离级别下幻读的问题。

## serializable（可串行化）

serializable是最高的隔离级别。它通过强制事务串行执行，避免了前面说的“幻读”的问题。简单来说，serializable会在读取的每一行上都加锁，所以可能导致大量的超时和锁竞争的问题。实际中也很少用到这个隔离级别，只有在非常需要确保数据的一致性，而且可以接收不能并发的情况下，才考虑使用此级别。

