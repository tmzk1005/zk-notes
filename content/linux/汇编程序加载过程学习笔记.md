---
title: "汇编程序加载过程学习笔记"
date: 2020-12-20T11:22:39+08:00
draft: false
toc: true
---

（以下的学习笔记基于i386，对于现在的64位系统就不一定对了）

引导扇区的大小只有512字节，实在是写不了很复杂的程序。那么操作系统那么大的程序，是怎么运行的？这就需要用这512个字节大小的引导扇区代码，将另外一个大型的，512字节装不下的程序，加载到内存中的某个地方，然后跳转到这个程序去执行。

引导扇区的代码最初是在硬盘上，是BIOS中的程序将它从硬盘加载到内存中的，硬盘中的其他代码要加载到内存，需要我们在引导扇区中编写代码去读硬盘了。

## 读硬盘

硬盘的读写基本单位是扇区，一个扇区是512字节，就是说，要读即至少读一个扇区，要写也也至少写一个扇区。（数据的读写是成块的，这就是linux中所谓的块设备）

一次扇区的读写是连续的，要读硬盘，那么我们要知道：

- 要读的扇区数
- 从那个扇区开始读，即起始扇区号

计算机为我们实现这2个目的提供了方法

个人计算机上，主硬盘控制器被分配了8个“端口”，端口号从0x1f0到0x1f7

在读硬盘时要把相关参数写入端口，写数据到端口用out指令

```asm
out dx, al
```

其中dx中存的是端口号，al中存的是要写到端口的数

### 设置要读的扇区数

要读的扇区数要写入端口0x1f2，这个端口是一个8位端口，可以写入的最大数是255，因此，读硬盘时一次只能读255个扇区。

```asm
mov dx, 0x1f2
mov al, 1
out dx, al
```

### 设置起始扇区号

扇区的读写是连续的，因此，只要设置第一个扇区的编号就可以了。LBA28的硬盘扇区编号使用28个bit，而每个端口只能写8个bit，所以要用4个端口来表示：

- 0x1f3 : 放0-7位
- 0x1f4 : 放8-15位
- 0x1f5 : 放16-23位
- 0x1f6 : 放24-27位

假设我们要读写的起始逻辑扇区号位0x02，则代码如下：

```asm
mov dx, 0x1f3
mov ax, 0x02
out dx, al

mov al, 0x00

inc dx
out dx, al

inc dx
out dx, al

inc dx
mov al, 0xe0
out dx, al
```

注意上面的倒数第2行，al不是0，而是改写为了0xe0，这是因为虽然后4个bit都需要是0，但是前4个bit还有别的用处。高3位全是1，表示硬盘是LBA模式，第4位指示硬盘号，0表示主盘，1表示从盘（在现在的体系，每个PATA/SATA接口可以挂接2块硬盘，分别是主盘和从盘，0表示主盘，1表示从盘）。

### 请求读硬盘

上面设置的扇区数目和起始扇区号即可以是用来读，也可以是用来写，既然我们是读，也要通过端口来告诉硬盘控制器，需要向0x1f7写入0x20表述读：

```asm
mov dx, 0x1f7
mov al, 0x20
out dx, al
```

### 等待读硬盘完成

设置好各端口的值后，硬盘就忙起来了，在它内部操作期间，他将0x1f7的第7位(最高位)设置位1，表示自己正忙着处理被吩咐的事。等它操作完成，就会将此位再清0，说明忙完了。同时将第3位设置位1，表示准备好了，请求主机发送或者接收数据。这一步的代码如下：

```asm
    mov dx, 0x1f7
wait:
    in al, dx
    and al, 1000_1000B
    cmp al, 0000_1000B
    jnz wait
```

jnz : 结果不为0则跳转。

当比较结果为0，则不跳转，循环结束。也就是需要：

```asm
al & 1000_1000B = 0000_1000B
```
那么，需要 al = 0000_1000B

### 取出数据

前面一直没用到的端口0x1f0是数据端口，这个端口是一个16位的端口，硬盘空闲，且准备就绪，就可以从这个端口读写数据。

循环从这个端口读出256字的数据（512字节）放到内存(段地址在ds中，这里没有设置)：

```asm
    mov cx, 256
    mov dx, 0x1f0
read:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop read
```

还有一个端口0x1f1没有用过，这个是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态，即错误原因。

### 封装读硬盘过程

读硬盘是经常要做的，可以封装成一个过程，封装的代码见下面的boot.asm文件中的`func_read_disk`


## 程序加载

我们利用1个扇区（0号扇区）编写一段代码，这段代码把第2个扇区（1号扇区）的512个字节加载到内存的合适的地方，然后跳转过去执行。这也算是一个简单的加载。

boot.asm

```asm

demo_app_addr equ 0x7c00 + 512

start:
    ; 设置al保存要读的扇区数1
    mov al, 1

    ; 设置DI:SI保存要读的起始扇区号1
    mov di, 0
    mov si, 1

    ; 设置DIS:BX保存被读出来的数据存放的位置
    mov cx, demo_app_addr
    mov ds, cx
    mov bx, 0

    ; 调用过程，加载程序
    call func_read_disk

    ; 跳转到被加载的程序
    jmp demo_app_addr:0

func_read_disk:
    ; ----------------------------
    ; 函数功能：读取硬盘
    ; 调用前设置参数：
    ;   DI:SI = 起始逻辑扇区号
    ;   DS:BX = 目标缓冲区地址
    ;   al    = 读取扇区数
    ; ----------------------------
    ; 寄存器压栈保存现场
    push ax
    push bx
    push cx
    push dx

    ; 设置读取扇区数
    mov dx, 0x1f2
    out dx, al

    ; 扇区数压栈，后面计算总读取字数的乘法指令要用时弹出来
    push ax

    ; 参数si中存着起始扇区号低16位
    ; mov到ax后，al存着低8位，ah存着8-15位
    mov ax, si

    ; 设置起始扇区号part1: 0x1f3
    inc dx
    out dx, al

    ; 设置起始扇区号part2: 0x1f4
    inc dx
    mov al, ah
    out dx, al

    ; 参数di中存着起始扇区号高12位
    ; mov到ax后，al存着16-23位， ah的后4个bit存着24-27位
    mov ax, di

    ; 设置起始扇区号part3: 0x1f5
    inc dx
    out dx, al

    ; 设置起始扇区号part4: 0x1f6
    ; 并同时设置0x1f6的高4位
    inc dx
    mov al, 0xe0
    or al, ah
    out dx, al

    ; 设置读命令
    inc dx
    mov al, 0x20
    out dx, al

wait_disk:
    ; 循环等待，直到硬盘就绪
    in al, dx
    and al, 1000_1000B
    cmp al, 0000_1000B
    jnz wait_disk

    pop ax
    ; 设置要读的字数等于 扇区数(在pop出来的al中) * 256
    ; al最大是255
    ; al * 256 最大为 255 * 256 < 64KB 不会超过一个逻辑段的大小
    mov ah, 0
    mov cx, 256
    mul cx
    ; 相乘结果是32位，DX:AX
    ; DX肯定全位0，所以相乘结果就是ax
    ; 把ax放入循环计数器cx
    mov cx, ax
    ; 设置读指令端口0x1f0
    mov dx, 0x1f0

readw:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop readw

    ; 还原
    pop dx
    pop cx
    pop bx
    pop ax

    ; 返回
    ret

times 510 - ($-$$) db 0
db 0x55, 0xaa
```

编译文件boot.asm得到512字节大小的文件boot

```asm
nams boot.asm
```

再写一个文件app.asm用来模拟被加载的程序，这个程序只是显示5个Hello

app.asm

```asm
; 此段代码被加载器加载到物理内存0x7c00+512处，并设置好了CS = 0x7c00+512，然后开始执行
me_cs equ 0x7c00+512
start:
    ; 设置DS = CS = 0x7c00+512
    mov ax, cs
    mov ds, ax

    ; 设置附加段基地址，es为0xb800,即显存内存地址
    mov ax, 0xb800
    mov es, ax

    ; cld 指令将DF标志置为0,以指示下面的movsw传送数据的方向是正方向
    ; 即从高地址到低地址
    cld
    ; 源地址 ： ds:si
    mov si, msg
    ; 目的地址： es:di
    mov di, 0
    ; 要传送的字数,放在cx中
    mov cx, (end - msg) / 2
    rep movsw

    ; 死循环
    jmp near $


msg:
    db 'H', 0x07, 'e', 0x07, 'l', 0x07, 'l', 0x07, 'o', 0x07
    db 'H', 0x07, 'e', 0x07, 'l', 0x07, 'l', 0x07, 'o', 0x07
    db 'H', 0x07, 'e', 0x07, 'l', 0x07, 'l', 0x07, 'o', 0x07
    db 'H', 0x07, 'e', 0x07, 'l', 0x07, 'l', 0x07, 'o', 0x07
    db 'H', 0x07, 'e', 0x07, 'l', 0x07, 'l', 0x07, 'o', 0x07
end:

; 补齐512个字节
times 512 - ($-$$) db 0
```

编译，得到512字节大小的文件app

```bash
nasm app.asm
```

然后，将2个512字节的文件，合并成1024字节大小的文件os

```bash
cat boot app > os
```

注意boot是引导扇区，在前，app在后

用qemu测试

```bash
qemu-system-i386 os
```

执行上面的命令就可以看到5个Hello了。

（显示5个Hello的功能不需要加载其他程序，引导扇区的512字节就够啦。这里主要是演示“加载”）


## 通用加载

前面的加载例子不是“通用的”。app被固定加载到了物理内存`0x7c00+512`的地方, app很简单，只有一个段。

如果一个app很复杂，用到了很多的段，怎么做一个加载器，使之能加载任意的程序到非固定的内存，然后跳转过去使之正确执行呢？

这就需要加载器和被加载的程序之间做一些约定，以达到通用的目的。比如说，规定被加载程序的第一个扇区的512字节中按照一定的格式保存程序的段信息，以及程序的名字，程序的长度等等信息。加载器加载程序时，先加载一个扇区，解析其中的信息，然后根据第一个扇区中的信息再加载剩余部分。

写这样一个加载器512个字节就不够了。所以需要用我们前面写的这样一个简单的加载器，去加载一个复杂的加载器，然后再让复杂的加载器去加载其他程序。

这个复杂的加载器从角色上来讲就是操作系统了。而上面说的约定，就设计到了操作系统的设计，这个约定里面蕴含的就是诸如段重定位啦，ELF可执行文件格式啦之类的了。
